# üöÄ FINAL OPTIMIZED PROMPT: VO Phase 3 ‚Äì The Iron Sandbox & Plugin Ecosystem

**Context:** Voyager Observatory (VO) v2.3.0 is stable. We are now implementing the **Plugin Ecosystem** based on the **Three-Layer Sovereignty Model**. This enables community-driven optics via a secure, high-performance Lua bridge. We are moving from a "Tool" to a "Programmable Platform."

## üéØ CRITICAL IMPROVEMENTS FROM PREVIOUS FEEDBACK

### **1. CONCRETE EXECUTION SEQUENCE**
Previous phases showed that **parallel execution** leads to dependency issues. This prompt structures a **linear, dependency-aware** build order:

```
Phase 0 ‚Üí Phase 1 ‚Üí Phase 2 ‚Üí Phase 3 ‚Üí Phase 4 ‚Üí Phase 5
```

### **2. SPECIFIC INTEGRATION POINTS**
Rather than vague "integrate with X," we specify **exact files and methods**:
- Update `src/core/lens_manager.rs:apply_plugin_filters()`
- Extend `src/core/metric_registry.rs:register_lua_metric()`
- Hook into `src/presenter/intelligent_presenter.rs:plugin_summary()`

### **3. COMPLETE ERROR HANDLING SCHEMA**
Define a proper error hierarchy:
```rust
enum PluginError {
    SandboxViolation(String),  // Security breach attempt
    TimeoutExceeded,           // >100ms execution
    MemoryQuotaExceeded,       // >10MB allocation
    ApiVersionMismatch,        // vo_api_version mismatch
    // ...
}
```

---

## üöÄ REFINED & EXECUTION-READY PROMPT

```bash
claude "task: Implement Phase 3 - The Plugin Ecosystem (The Iron Sandbox)

## CONTEXT
VO v2.3.0 with Chronos Engine is operational. Now build the Lua plugin system using the Three-Layer Sovereignty Model.

## ARCHITECTURAL PRINCIPLES
1. **Sovereignty Model**: Plugins can only APPEND, never mutate core data
2. **Iron Sandbox**: 100ms timeout, 10MB memory limit, stripped Lua libs
3. **Deterministic Output**: Plugin data merged via BTreeMap for byte-parity
4. **Graceful Degradation**: Plugins disabled = zero performance impact

## TASK 0: DOCUMENTATION & FEATURE FLAGS
**Objective:** Update docs and configure build system.

1. **Update Fractal Protocol Spec:**
```bash
sed -i 's/Phase 3: Plugin Ecosystem \[PLANNED\]/Phase 3: Plugin Ecosystem \[IMPLEMENTING\]/g' docs/specs/v2.0_FRACTAL_PROTOCOL_SPEC.md
echo '- Added Three-Layer Sovereignty Model' >> docs/specs/v2.0_FRACTAL_PROTOCOL_SPEC.md
echo '- Lua sandbox with 100ms/10MB limits' >> docs/specs/v2.0_FRACTAL_PROTOCOL_SPEC.md
```

2. **Create Plugin Architecture Document:**
```bash
mkdir -p docs/arch/
cat > docs/arch/PLUGIN_ARCHITECTURE.md << 'EOF'
# Plugin Architecture: Three-Layer Sovereignty

## MODEL OVERVIEW
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ          LAYER 3: LUA PLUGINS           ‚îÇ
‚îÇ  ‚Ä¢ Append-only contributions            ‚îÇ
‚îÇ  ‚Ä¢ 100ms CPU / 10MB RAM limits          ‚îÇ
‚îÇ  ‚Ä¢ vo.* API bridge                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ         LAYER 2: SYNTAX PROVIDERS       ‚îÇ
‚îÇ  ‚Ä¢ Rust-native heuristic adapters       ‚îÇ
‚îÇ  ‚Ä¢ Tree-sitter parsers                  ‚îÇ
‚îÇ  ‚Ä¢ Regex engine (cached)                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ          LAYER 1: FRACTAL CORE          ‚îÇ
‚îÇ  ‚Ä¢ Memory-mapped AST storage            ‚îÇ
‚îÇ  ‚Ä¢ Normalized representation            ‚îÇ
‚îÇ  ‚Ä¢ Immutable data structures            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

## SOVEREIGNTY RULE
Plugins can ONLY:
- Register new metrics for Celestial Census
- Contribute tags to existing nodes
- Append log entries to Mission Log

Plugins CANNOT:
- Mutate or delete core-discovered data
- Access filesystem, network, or processes
- Bypass timeout or memory limits
EOF
```

3. **Add Feature Gate to Cargo.toml:**
```toml
[dependencies]
mlua = { version = "0.9", features = ["lua54", "vendored"], optional = true }

[features]
default = []
plugins = ["dep:mlua"]  # Explicit feature gate
```

## TASK 1: PLUGIN KERNEL & IRON SANDBOX
**Objective:** Create secure Lua runtime with hard limits.

1. **Module Structure:**
```bash
mkdir -p src/core/plugins/{bridges,errors}
touch src/core/plugins/{mod.rs,engine.rs,sandbox.rs,loader.rs}
touch src/core/plugins/errors.rs
touch src/core/plugins/bridges/{mod.rs,vo_table.rs,patterns.rs}
```

2. **Implement `Sandbox` in `sandbox.rs`:**
```rust
use mlua::{Lua, Result};
use std::time::{Duration, Instant};

pub struct IronSandbox {
    lua: Lua,
    timeout: Duration,
    memory_limit: usize,
}

impl IronSandbox {
    pub fn new() -> Result<Self> {
        let lua = Lua::new();
        
        // STRIP DANGEROUS LIBRARIES
        let globals = lua.globals();
        globals.set("io", mlua::Value::Nil)?;
        globals.set("os", mlua::Value::Nil)?;
        globals.set("debug", mlua::Value::Nil)?;
        globals.set("package", mlua::Value::Nil)?;
        
        // Remove load/dofile functions
        globals.set("load", mlua::Value::Nil)?;
        globals.set("loadfile", mlua::Value::Nil)?;
        globals.set("dofile", mlua::Value::Nil)?;
        
        // SET RESOURCE LIMITS
        lua.set_memory_limit(10 * 1024 * 1024)?; // 10MB
        
        Ok(Self {
            lua,
            timeout: Duration::from_millis(100),
            memory_limit: 10 * 1024 * 1024,
        })
    }
    
    pub fn execute_with_timeout<F, R>(&self, f: F) -> Result<R>
    where
        F: FnOnce(&Lua) -> Result<R>,
    {
        let start = Instant::now();
        
        // Set interrupt handler for timeout
        self.lua.set_interrupt_handler(Some(Box::new(|| {
            if start.elapsed() > self.timeout {
                Err(mlua::Error::RuntimeError("Timeout exceeded".to_string()))
            } else {
                Ok(())
            }
        })))?;
        
        let result = f(&self.lua);
        
        // Clear interrupt handler
        self.lua.set_interrupt_handler(None)?;
        
        result
    }
}
```

## TASK 2: THE `vo.*` BRIDGE API
**Objective:** Expose curated Observatory capabilities.

1. **Create `vo` global table in `vo_table.rs`:**
```rust
use mlua::{Lua, Table, Value};
use crate::core::regex_engine::RegexEngine;

pub fn create_vo_table(lua: &Lua) -> mlua::Result<Table> {
    let vo = lua.create_table()?;
    
    // API version
    vo.set("api_version", "3.0")?;
    
    // Regex bridge (from Phase 1B)
    vo.set("regex", lua.create_function(|lua, pattern: String| {
        let engine = RegexEngine::global();
        let compiled = engine.compile(&pattern)
            .map_err(|e| mlua::Error::RuntimeError(format!("Regex error: {}", e)))?;
        
        // Return as Lua function that takes text
        lua.create_function(move |_, text: String| {
            let matches = compiled.find_iter(&text).collect::<Vec<_>>();
            Ok(matches.len())
        })
    })?)?;
    
    // AST proxy (immutable)
    vo.set("ast", lua.create_function(|_, path: String| {
        // TODO: Hook into existing AST bridge
        // Return read-only proxy table
        Ok(lua.create_table()?)
    })?)?;
    
    // Pre-compiled patterns
    let patterns = lua.create_table()?;
    patterns.set("rust_fn", r"fn\s+(\w+)")?;
    patterns.set("python_def", r"def\s+(\w+)")?;
    vo.set("patterns", patterns)?;
    
    // Logging bridge
    vo.set("log", lua.create_function(|_, (level, msg): (String, String)| {
        // TODO: Hook into IntelligentPresenter
        println!("[{}] {}", level, msg);
        Ok(())
    })?)?;
    
    // Metric registration
    vo.set("register_metric", lua.create_function(|lua, (name, callback): (String, mlua::Function)| {
        // TODO: Register with MetricRegistry
        Ok(())
    })?)?;
    
    // Tag contribution
    vo.set("contribute_tag", lua.create_function(|_, (node_id, tag): (String, String)| {
        // TODO: Append to tag registry
        Ok(())
    })?)?;
    
    Ok(vo)
}
```

## TASK 3: DISCOVERY & MANIFEST SYSTEM
**Objective:** Load plugins from standard paths.

1. **Implement `PluginLoader` in `loader.rs`:**
```rust
use serde::Deserialize;
use std::path::{Path, PathBuf};

#[derive(Debug, Deserialize)]
pub struct PluginManifest {
    pub vo_api_version: String,
    pub plugins: Vec<PluginEntry>,
}

#[derive(Debug, Deserialize)]
pub struct PluginEntry {
    pub name: String,
    pub file: String,
    pub enabled: bool,
    pub priority: i32,
}

pub struct PluginLoader {
    search_paths: Vec<PathBuf>,
}

impl PluginLoader {
    pub fn new() -> Self {
        let mut paths = Vec::new();
        
        // Local project plugins
        if let Ok(cwd) = std::env::current_dir() {
            paths.push(cwd.join(".vo/plugins"));
        }
        
        // User-global plugins
        if let Some(home) = dirs::home_dir() {
            paths.push(home.join(".config/vo/plugins"));
        }
        
        Self { search_paths: paths }
    }
    
    pub fn discover_plugins(&self) -> Vec<PluginEntry> {
        let mut plugins = Vec::new();
        
        for path in &self.search_paths {
            let manifest_path = path.join("manifest.json");
            if manifest_path.exists() {
                if let Ok(contents) = std::fs::read_to_string(&manifest_path) {
                    if let Ok(manifest) = serde_json::from_str::<PluginManifest>(&contents) {
                        // Check API version compatibility
                        if manifest.vo_api_version == "3.0" {
                            plugins.extend(manifest.plugins.into_iter().filter(|p| p.enabled));
                        }
                    }
                }
            }
        }
        
        // Sort by priority (higher first)
        plugins.sort_by(|a, b| b.priority.cmp(&a.priority));
        plugins
    }
}
```

## TASK 4: INTEGRATION POINTS
**Objective:** Connect plugins to existing systems.

1. **Extend `MetricRegistry` (from Phase 1C):**
```rust
// In src/core/metric_registry.rs
#[cfg(feature = "plugins")]
use crate::core::plugins::LuaMetricCollector;

pub struct MetricRegistry {
    rust_collectors: Vec<Box<dyn MetricCollector>>,
    #[cfg(feature = "plugins")]
    lua_collectors: Vec<LuaMetricCollector>,
}

impl MetricRegistry {
    #[cfg(feature = "plugins")]
    pub fn register_lua_metric(&mut self, name: String, lua_fn: mlua::Function) {
        self.lua_collectors.push(LuaMetricCollector::new(name, lua_fn));
    }
}
```

2. **Update `IntelligentPresenter`:**
```rust
// In src/presenter/intelligent_presenter.rs
pub fn generate_plugin_summary(&self, plugin_count: usize, loaded_plugins: &[String]) -> String {
    if plugin_count == 0 {
        return String::from("üîå No external optics detected.");
    }
    
    let mut output = format!("üîå External Optics: {} community plugins loaded\n", plugin_count);
    for plugin in loaded_plugins {
        output.push_str(&format!("   ‚îú‚îÄ {}\n", plugin));
    }
    output.push_str("üõ°Ô∏è Plugin sandbox: Active (10MB memory, 100ms timeout)\n");
    output
}
```

## TASK 5: COMPREHENSIVE TDD SUITE
**Objective:** Prove security and functionality.

1. **Create test file:**
```bash
touch tests/test_plugin_ecosystem.rs
```

2. **Implement adversarial tests:**
```rust
// tests/test_plugin_ecosystem.rs
#[cfg(feature = "plugins")]
mod tests {
    use super::*;
    
    #[test]
    fn test_sandbox_escape() {
        let sandbox = IronSandbox::new().unwrap();
        
        // Test os.execute is disabled
        let result = sandbox.execute_with_timeout(|lua| {
            lua.load("return os.execute('echo hacked')").eval::<()>()
        });
        
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("nil"));
    }
    
    #[test]
    fn test_resource_exhaustion() {
        let sandbox = IronSandbox::new().unwrap();
        
        let start = std::time::Instant::now();
        let result = sandbox.execute_with_timeout(|lua| {
            lua.load("while true do end").eval::<()>()
        });
        
        assert!(result.is_err());
        assert!(start.elapsed() < std::time::Duration::from_millis(150)); // Within tolerance
    }
    
    #[test]
    fn test_vo_api_bridge() {
        let sandbox = IronSandbox::new().unwrap();
        
        let result = sandbox.execute_with_timeout(|lua| {
            // Create vo table
            let vo = crate::core::plugins::bridges::vo_table::create_vo_table(lua)?;
            lua.globals().set("vo", vo)?;
            
            // Test regex bridge
            lua.load(r#"
                local pattern = vo.regex("test")
                local count = pattern("this is a test")
                return count
            "#).eval::<i32>()
        });
        
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), 1); // "test" appears once
    }
    
    #[test]
    fn test_custom_metric_integration() {
        // Test that Lua metric appears in census
        let test_lua = r#"
            vo.register_metric("todo_counter", function(ast)
                -- Count TODO comments
                local count = 0
                for _, comment in ipairs(ast.comments or {}) do
                    if string.find(comment.text, "TODO") then
                        count = count + 1
                    end
                end
                return {
                    value = count,
                    confidence = 0.8,
                    explanation = "Found " .. count .. " TODO comments"
                }
            end)
        "#;
        
        // TODO: Load plugin and verify metric appears in --survey composition
    }
}
```

## CRITICAL SUCCESS METRICS

1. **Security:** All 6 adversarial tests pass
2. **Performance:** Plugin overhead <5ms when disabled, <50ms when enabled
3. **Integration:** `vo . --plugins list` shows loaded plugins
4. **Determinism:** Same input ‚Üí same output byte-for-byte
5. **Graceful Degradation:** `cargo build --no-default-features` produces working binary

## EXECUTION ORDER

1. **Run Phase 0 immediately** (documentation updates)
2. **Then Phase 1** (mlua dependency + sandbox)
3. **Then Phase 2** (vo.* API bridge)
4. **Then Phase 3** (discovery system)
5. **Then Phase 4** (integration points)
6. **Then Phase 5** (TDD verification)

## RISK MITIGATION

**Risk:** mlua compilation issues
**Mitigation:** Use vendored Lua, test on clean environment

**Risk:** Performance regression
**Mitigation:** Feature gate all plugin code, benchmark before/after

**Risk:** Security vulnerability
**Mitigation:** Adversarial tests, stripped libraries, resource limits

---

**READY TO EXECUTE.** This prompt contains every detail needed for Claude Code CLI to build the complete Plugin Ecosystem from scratch.

Launch Phase 3 now. The gates await. üåå‚ú®üîå"
